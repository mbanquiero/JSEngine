<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		
		<title>JsDoc Reference - File Index</title>
		<meta name="generator" content="JsDoc Toolkit" />
		
		<style type="text/css">
		/* default.css */
body
{
	font: 12px "Lucida Grande", Tahoma, Arial, Helvetica, sans-serif;
	width: 800px;
}

.header
{
	clear: both;
	background-color: #ccc;
	padding: 8px;
}

h1
{
	font-size: 150%;
	font-weight: bold;
	padding: 0;
	margin: 1em 0 0 .3em;
}

hr
{
	border: none 0;
	border-top: 1px solid #7F8FB1;
	height: 1px;
}

pre.code
{
	display: block;
	padding: 8px;
	border: 1px dashed #ccc;
}

#index
{
	margin-top: 24px;
	float: left;
	width: 160px;
	position: absolute;
	left: 8px;
	background-color: #F3F3F3;
	padding: 8px;
}

#content
{
	margin-left: 190px;
	width: 600px;
}

.classList
{
	list-style-type: none;
	padding: 0;
	margin: 0 0 0 8px;
	font-family: arial, sans-serif;
	font-size: 1em;
	overflow: auto;
}

.classList li
{
	padding: 0;
	margin: 0 0 8px 0;
}

.summaryTable { width: 100%; }

h1.classTitle
{
	font-size:170%;
	line-height:130%;
}

h2 { font-size: 110%; }
caption, div.sectionTitle
{
	background-color: #7F8FB1;
	color: #fff;
	font-size:130%;
	text-align: left;
	padding: 2px 6px 2px 6px;
	border: 1px #7F8FB1 solid;
}

div.sectionTitle { margin-bottom: 8px; }
.summaryTable thead { display: none; }

.summaryTable td
{
	vertical-align: top;
	padding: 4px;
	border-bottom: 1px #7F8FB1 solid;
	border-right: 1px #7F8FB1 solid;
}

/*col#summaryAttributes {}*/
.summaryTable td.attributes
{
	border-left: 1px #7F8FB1 solid;
	width: 140px;
	text-align: right;
}

td.attributes, .fixedFont
{
	line-height: 15px;
	color: #002EBE;
	font-family: "Courier New",Courier,monospace;
	font-size: 13px;
}

.summaryTable td.nameDescription
{
	text-align: left;
	font-size: 13px;
	line-height: 15px;
}

.summaryTable td.nameDescription, .description
{
	line-height: 15px;
	padding: 4px;
	padding-left: 4px;
}

.summaryTable { margin-bottom: 8px; }

ul.inheritsList
{
	list-style: square;
	margin-left: 20px;
	padding-left: 0;
}

.detailList {
	margin-left: 20px; 
	line-height: 15px;
}
.detailList dt { margin-left: 20px; }

.detailList .heading
{
	font-weight: bold;
	padding-bottom: 6px;
	margin-left: 0;
}

.light, td.attributes, .light a:link, .light a:visited
{
	color: #777;
	font-style: italic;
}

.fineprint
{
	text-align: right;
	font-size: 10px;
}
		</style>
	</head>
	
	<body>
		<div id="header">
</div>
		
		<div id="index">
			<div align="center"><a href="index.html">Class Index</a>
| <a href="files.html">File Index</a></div>
<hr />
<h2>Classes</h2>
<ul class="classList">
	
	<li><i><a href="symbols/_global_.html">_global_</a></i></li>
	
	<li><a href="symbols/Body.html">Body</a></li>
	
	<li><a href="symbols/Constraint.html">Constraint</a></li>
	
	<li><a href="symbols/ContactSolver.html">ContactSolver</a></li>
	
	<li><a href="symbols/GeoCircle.html">GeoCircle</a></li>
	
	<li><a href="symbols/GeoPolygon.html">GeoPolygon</a></li>
	
	<li><a href="symbols/Matrix2.html">Matrix2</a></li>
	
	<li><a href="symbols/Vector2.html">Vector2</a></li>
	
	<li><a href="symbols/World.html">World</a></li>
	
</ul>
<hr />
		</div>
		
		<div id="content">
			<h1 class="classTitle">File Index</h1>
			
			
			<div>
				<h2><a href="symbols/src/C__uade_JSEngine_engine_math.js.html">math.js</a></h2>
				
math.js
	Implementa algebra lineal de vectores 2d 
	matrices 2 x 2, usadas para la rotacion del cuerpo rigido
				<dl>
					
					
					
					
				</dl>
			</div>
			<hr />
			
			<div>
				<h2><a href="symbols/src/C__uade_JSEngine_engine_world.js.html">world.js</a></h2>
				
world.js
<P> motor de fisica 2d de proposito didactivo basado en impulse resolution</P>
<P>  features</P>
<P>  - rigid body: circulos y poligonos concavos</P>
<P>  - soporta oriented rigid body </P>
<P>  - algoritmo de integracion: euler modificado</P>
<P> - algoritmo de deteccion de colisiones: SAT</P>
<P>  - constratints : joints </P>
<P>  - Ragdall y softbidy : implmementados con distance constraints</P>
				<dl>
					
					
					
					
				</dl>
			</div>
			<hr />
			
			<div>
				<h2><a href="symbols/src/C__uade_JSEngine_engine_contact.js.html">contact.js</a></h2>
				
contact.js

<P> Collision response (impulse resolution)</P>
<P> Los motores de fisicas usualmente tienen 2 etapas bien definidas</P>
<P> * Etapa de Collision Detection: el objetivo de esta etapa es determinar si 2 o mas cuerpos entran en colision. </P>
<P> PAra ello se aplican una serie de algoritmos geometricos bastante estudiados. </P>
<P> Esta etapa a su vez se puede dividir en 2 fases :</P>
<P>              - Broad Phase. </P>
<P>	Se trata de rapidamente descartar aquellos pares de cuerpos que por estar lo suficienemente
                              alejados no pueden entrar en colision. Se suelen usar bounding box y otro tipo de simplificaciones
                              y distintas estructuras jerarquicas. La idea es que rapidamente se puedan detectar pares de 
                              candidatos que pueden entrar en colision.</P>
							  
<P>              - Narrow Phase. </P>
<P>Con el resultado de pares "posibles" de la fase anterior, se determinar exactamente si 
                              esos "candidatos" a colision, realmente estaban colisionando, y en caso afirmativo
                              colectar informacion especifica de la colision, que luego va a servir en etapas posteriores
                              como el punto exacto de la colision, la normal, y la penetracion.</P>
							  
<P> * Etapa de Collision Response : una vez dectectada la collision, el motor tiene que tomar alguna acción para evitar
 que los cuerpos que collisionaron siguen en esa situacion. En nuestro caso se resuelve aplicando un impulso de tal forma
 que los cuerpos se alejen en la direccion que chocaron,  y asi evitar que sigan en colision = Impulse Resolution.</P>
<P> A continuacion se codifican los algortimos de Impulse Resolution.</P>
<P> Impulse Resolution es una de las tantas formas estandard de los motores de fisica de resolver la colision entre cuerpos
 La idea es aplicar un impulso (cambio instantaneo en la velocidad) a los cuerpos que entran en colision, de tal manera
 que tienan a separarse. </P>
<P>Los algoritmos que detectan la colision tambien informan la normal de la colision, el punto de contacto y la penetracion</P>
				<dl>
					
					
					
					
				</dl>
			</div>
			<hr />
			
			<div>
				<h2><a href="symbols/src/C__uade_JSEngine_engine_constraint.js.html">constraint.js</a></h2>
				
constraint.js
<P> Implementa restricciones entre 2 cuerpos</P>
<P>  -distancia</P>
<P>  -angulo</P>
<P>  -joint</P>
				<dl>
					
					
					
					
				</dl>
			</div>
			<hr />
			
			<div>
				<h2><a href="symbols/src/C__uade_JSEngine_engine_collision.js.html">collision.js</a></h2>
				
collision.js
<P> Implementa colisiones entre 2 cuerpos</P>
<P>  Fase de Collision Detection</P> 
<P> Los motores de fisicas usualmente tienen 2 etapas bien definidas</P>
<P> * Etapa de Collision Detection: el objetivo de esta etapa es determinar si 2 o mas cuerpos entran en colision. </P>
<P> PAra ello se aplican una serie de algoritmos geometricos bastante estudiados. </P>
<P> Esta etapa a su vez se puede dividir en 2 fases :</P>
<P>              - Broad Phase. Se trata de rapidamente descartar aquellos pares de cuerpos que por estar lo suficienemente
                              alejados no pueden entrar en colision. Se suelen usar bounding box y otro tipo de simplificaciones
                              y distintas estructuras jerarquicas. La idea es que rapidamente se puedan detectar pares de 
                              candidatos que pueden entrar en colision.</P>
							  
<P>              - Narrow Phase. Con el resultado de pares "posibles" de la fase anterior, se determinar exactamente si 
                              esos "candidatos" a colision, realmente estaban colisionando, y en caso afirmativo
                              colectar informacion especifica de la colision, que luego va a servir en etapas posteriores
                              como el punto exacto de la colision, la normal, y la penetracion.</P>
							  
<P> * Etapa de Collision Response : una vez dectectada la collision, el motor tiene que tomar alguna acción para evitar
 que los cuerpos que collisionaron siguen en esa situacion. En nuestro caso se resuelve aplicando un impulso de tal forma
 que los cuerpos se alejen en la direccion que chocaron,  y asi evitar que sigan en colision = Impulse Resolution.</P>
 

<P> En este motor no tenemos Broad Phase, los algoritmos que se codifican a continuacion, corresponden a la llamada
 Narrow Phase, y tienen por objetivo determianr si hay o no colision, y en casi que asi fuera computar:</P>
 
<P> i) punto de contacto</P>
<P> ii) direccion normal de la colision</P>
<P> iii) penetracion</P>
<P> puede que los cuerpos entre en colision en mas de un punto, por eso la informacion de contacto tiene un array 
y una cantidad de contactos.</P>
				<dl>
					
					
					
					
				</dl>
			</div>
			<hr />
			
			<div>
				<h2><a href="symbols/src/C__uade_JSEngine_engine_body.js.html">body.js</a></h2>
				
body.js
<P> Implementa formas geometricas basicas</P>
<P>  -circulo</P>
<P>  -caja</P>
<P>  -triangulo</P>
<P>  -poligono</P>
<P>  Implementa dinamica de cuerpo rigido</P>
				<dl>
					
					
					
					
				</dl>
			</div>
			<hr />
			
			
		</div>
		<div class="fineprint" style="clear:both">
			
			Documentation generated by <a href="http://code.google.com/p/jsdoc-toolkit/" target="_blankt">JsDoc Toolkit</a> 2.4.0 on Thu May 14 2015 12:35:54 GMT-0300 (ART)
		</div>
	</body>
</html>